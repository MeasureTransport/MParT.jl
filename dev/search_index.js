var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = MParT","category":"page"},{"location":"#MParT","page":"Home","title":"MParT","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MParT.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [MParT]","category":"page"},{"location":"#MParT.ComposedMap-Tuple{Vector{<:CxxWrap.StdLib.SharedPtr{<:MParT.ConditionalMapBase}}}","page":"Home","title":"MParT.ComposedMap","text":"`ComposedMap(maps::Vector)`\n\nCreates a ComposedMap from a vector of ConditionalMapBase objects.\n\n\n\n\n\n","category":"method"},{"location":"#MParT.MultiIndex-Tuple{AbstractVector{<:Int64}}","page":"Home","title":"MParT.MultiIndex","text":"MultiIndex(A::AbstractVector{<:Int})\n\nMultiIndex defines the order of one term of a function expansion for each dimensions.\n\nExample\n\njulia> degrees = [3,2,1]; # Represents polynomial basis function similar to x^3y^2z^1\n\njulia> midx = MultiIndex(degrees);\n\njulia> midx[3]\n0x00000001\n\nSee also MultiIndexSet, FixedMultiIndexSet, Fix\n\n\n\n\n\n","category":"method"},{"location":"#MParT.MultiIndexSet-Tuple{AbstractMatrix{<:Integer}}","page":"Home","title":"MParT.MultiIndexSet","text":"MultiIndexSet(A::AbstractVecOrMat{<:Integer})\n\nCreate a set of MultiIndices from the rows of A.\n\nThese indices represent a basis for a multivariate expansion or, further, monotone expansion. Each element of the set is a MultiIndex representing one basis function via the degrees in each dimension.\n\nExample\n\njulia> # Functions like: c_1xy^2z^3 + c_2xyz + c_3\n\njulia> A = [1 2 3;1 1 1; 0 0 0];\n\njulia> mset = MultiIndexSet(A);\n\nSee alsoMultiIndex, FixedMultiIndex, Fix\n\n\n\n\n\n","category":"method"},{"location":"#MParT.TriangularMap-Tuple{Vector}","page":"Home","title":"MParT.TriangularMap","text":"`TriangularMap(maps::Vector)`\n\nCreates a TriangularMap from a vector of ConditionalMapBase objects.\n\nExamples\n\njulia> dim, order = 5, 3\n\njulia> msets = [FixedMultiIndexSet(d, order) for d in 1:dim]\n\njulia> opts = MapOptions()\n\njulia> components = [CreateComponent(mset, opts) for mset in msets]\n\njulia> trimap = TriangularMap(components)\n\n\n\n\n\n","category":"method"},{"location":"#MParT.ATMOptions-Tuple{}","page":"Home","title":"MParT.ATMOptions","text":"`ATMOptions(;kwargs...)`\n\nTakes the fields from MParT's ATMOptions as keyword arguments, and assigns the field value based on a String from keyword arguments.\n\nExamples\n\njulia> maxDegrees = MultiIndex(2,3) # limit both dimensions by order 3\n\njulia> ATMOptions(opt_alg=\"LD_SLSQP\", maxDegrees=maxDegrees)\n\n\n\n\n\n","category":"method"},{"location":"#MParT.CreateGaussianKLObjective","page":"Home","title":"MParT.CreateGaussianKLObjective","text":"CreateGaussianKLObjective(train)\nCreateGaussianKLObjective(train, outputDim)\nCreateGaussianKLObjective(train, test)\nCreateGaussianKLObjective(train, test, outputDim)\n\nCreate an objective for the optimization problem of training a transport map.\n\nCurrently only supports variational simulation-based inference, i.e. creating a map that uses samples train from target distribution and a Gaussian reference distribution of dimension outputDim. If outputDim is zero, this is equivalent to when outputDim == size(train,1).\n\nArguments\n\ntrain::Matrix{Float64}: mandatory training dataset\ntest::Matrix{Float64}: optional test dataset\noutputDim::Int = 0: Dimensions of output of map\n\nExamples\n\njulia> using Random; rng = Random.Xoshiro(1);\n\njulia> # Replace RNG type with MersenneTwister for <1.7\n\njulia> N, inDim, outDim = 1000, 4, 2;\n\njulia> samples = 2*randn(rng, inDim, N) .+ 5;\n\njulia> obj1 = CreateGaussianKLObjective(samples);\n\njulia> obj2 = CreateGaussianKLObjective(samples, outDim);\n\njulia> train, test = samples[:,1:500], samples[:,501:end];\n\njulia> obj3 = CreateGaussianKLObjective(train, test);\n\njulia> obj4 = CreateGaussianKLObjective(train, test, outDim);\n\n\n\n\n\n","category":"function"},{"location":"#MParT.DeserializeMap-Tuple{String}","page":"Home","title":"MParT.DeserializeMap","text":"DeserializeMap(filename::String)\n\nREQUIRES CEREAL INSTALLATION. Deserializes a map and returns its input dimension, output dimension, and coefficient.\n\n\n\n\n\n","category":"method"},{"location":"#MParT.MapOptions-Tuple{}","page":"Home","title":"MParT.MapOptions","text":"MapOptions(;kwargs...)\n\nTakes the fields from MParT's MapOptions as keyword arguments, and assigns the field value based on a String from the kwarg value.\n\nArguments\n\n``\n\nExample\n\njulia> using MParT\n\njulia> MapOptions(basisType=\"HermiteFunctions\", basisLB=-3., basisUB=3.)\n\n\n\n\n\n","category":"method"},{"location":"#MParT.TrainMapAdaptive-Tuple{Vector{<:MultiIndexSet}, CxxWrap.StdLib.SharedPtr{<:MParT.MapObjective}, MParT.__ATMOptions}","page":"Home","title":"MParT.TrainMapAdaptive","text":"TrainMapAdaptive(msets, objective, options)\n\nThis implements the ATM algorithm (Baptista et al. 2022), which takes in an initial guess of multiindex sets for each output dimension and adapts those sets to better suit the probability distribution.\n\nExamples\n\n\n\n\n\n","category":"method"},{"location":"#MParT.TrainOptions-Tuple{}","page":"Home","title":"MParT.TrainOptions","text":"`TrainOptions(;kwargs...)`\n\nTakes the fields from MParT's TrainOptions as keyword arguments, and assigns the field value based on a String from keyword arguments.\n\nArguments\n\n-``:\n\nExamples\n\njulia> TrainOptions(opt_alg=\"LD_SLSQP\")\n\n\n\n\n\n","category":"method"}]
}
