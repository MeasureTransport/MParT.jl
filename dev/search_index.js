var documenterSearchIndex = {"docs":
[{"location":"multiindex/","page":"MultiIndices","title":"MultiIndices","text":"CurrentModule = MParT","category":"page"},{"location":"multiindex/#MultiIndex-related-routines","page":"MultiIndices","title":"MultiIndex-related routines","text":"","category":"section"},{"location":"multiindex/","page":"MultiIndices","title":"MultiIndices","text":"MultiIndex\nMultiIndexSet\nFixedMultiIndexSet\nFix\nCreateTotalOrder\nSize","category":"page"},{"location":"multiindex/#MParT.MultiIndex","page":"MultiIndices","title":"MParT.MultiIndex","text":"MultiIndex(A::AbstractVector{<:Int})\n\nMultiIndex defines the order of one term of a function expansion for each dimensions.\n\nExample\n\njulia> degrees = [3,2,1]; # Represents polynomial basis function similar to x^3y^2z^1\n\njulia> midx = MultiIndex(degrees);\n\njulia> midx[3]\n0x00000001\n\nSee also MultiIndexSet, FixedMultiIndexSet, Fix\n\n\n\n\n\n","category":"type"},{"location":"multiindex/#MParT.MultiIndexSet","page":"MultiIndices","title":"MParT.MultiIndexSet","text":"MultiIndexSet(A::AbstractVecOrMat{<:Integer})\n\nCreate a set of MultiIndices from the rows of A.\n\nThese indices represent a basis for a multivariate expansion or, further, monotone expansion. Each element of the set is a MultiIndex representing one basis function via the degrees in each dimension.\n\nExample\n\njulia> # Functions like: c_1xy^2z^3 + c_2xyz + c_3\n\njulia> A = [1 2 3;1 1 1; 0 0 0];\n\njulia> mset = MultiIndexSet(A);\n\nSee also MultiIndex, FixedMultiIndexSet, Fix\n\n\n\n\n\n","category":"type"},{"location":"multiindex/#MParT.FixedMultiIndexSet","page":"MultiIndices","title":"MParT.FixedMultiIndexSet","text":"FixedMultiIndexSet(dim::Int, p::Int)\n\nCreates a FixedMultiIndexSet with dimension dim and total order p.\n\nA FixedMultiIndexSet is just a compressed, efficient way of representing a MultiIndexSet, but without as many bells and whistles.\n\nSee also: MultiIndex, MultiIndexSet\n\n\n\n\n\n","category":"type"},{"location":"multiindex/#MParT.Fix","page":"MultiIndices","title":"MParT.Fix","text":"Fix(mset::MultiIndexSet, compress::Bool = true)\n\nTake mset and turn it into a FixedMultiIndexSet that can be compressed.\n\nSee also MultiIndex, MultiIndexSet, FixedMultiIndexSet\n\n\n\n\n\n","category":"function"},{"location":"multiindex/#MParT.CreateTotalOrder","page":"MultiIndices","title":"MParT.CreateTotalOrder","text":"CreateTotalOrder(dim::Int, p::Int)\n\nCreates a total order p MultiIndexSet object in dimension dim.\n\nSee also: MultiIndexSet\n\n\n\n\n\n","category":"function"},{"location":"multiindex/#MParT.Size","page":"MultiIndices","title":"MParT.Size","text":"Size(mset::MultiIndexSet)\n\nNumber of MultiIndex objects in a MultiIndexSet mset.\n\n\n\n\n\n","category":"function"},{"location":"map/","page":"Map Functionality","title":"Map Functionality","text":"CurrentModule = MParT","category":"page"},{"location":"map/#Basic-map-Routines","page":"Map Functionality","title":"Basic map Routines","text":"","category":"section"},{"location":"map/","page":"Map Functionality","title":"Map Functionality","text":"Evaluate\nInverse\nComposedMap\nMapOptions\nTriangularMap\nCreateTriangular\nCreateComponent","category":"page"},{"location":"map/#MParT.Evaluate","page":"Map Functionality","title":"MParT.Evaluate","text":"Evaluate(map, points)\n\nEvaluates the function map at points, where each column of points is a different sample.\n\nIf map mathbbR^mtomathbbR^n, then points inmathbbR^mtimesmathbbR^k, where k is the number of points.\n\n\n\n\n\n","category":"function"},{"location":"map/#MParT.Inverse","page":"Map Functionality","title":"MParT.Inverse","text":"Inverse(map, y, x)\n\nIf map represents function T(yx), then this function calculates T(ycdot)^-1(x).\n\nIf map is square, you still require y, but it can be a 0 x k matrix.\n\n\n\n\n\n","category":"function"},{"location":"map/#MParT.ComposedMap","page":"Map Functionality","title":"MParT.ComposedMap","text":"ComposedMap(maps::Vector)\n\nCreates a ComposedMap from a vector of ConditionalMapBase objects.\n\n\n\n\n\n","category":"type"},{"location":"map/#MParT.MapOptions","page":"Map Functionality","title":"MParT.MapOptions","text":"MapOptions(;kwargs...)\n\nCreates options for parameterized map.\n\nAll possible keyword arguments are in example, with some important arguments described below. See C++ documentation for an exhaustive description.\n\nArguments\n\nbasisType::String: Includes \"ProbabilistHermite\", \"PhysicistHermite\", \"HermiteFunctions\"\nbasisLB::Float64,basisUB::Float64: The bounds for where we start linearizing the map. These default to infinities, but often making the data near the origin and setting them to a small finite number (e.g. +-3) works well.\n\nExample\n\njulia> MapOptions(basisType=\"HermiteFunctions\", basisLB=-3., basisUB=3.)\nbasisType = HermiteFunctions\nbasisLB = -3\nbasisUB = 3\nbasisNorm = true\nposFuncType = SoftPlus\nquadType = AdaptiveSimpson\nquadAbsTol = 1e-06\nquadRelTol = 1e-06\nquadMaxSub = 30\nquadMinSub = 0\nquadPts = 5\ncontDeriv = true\nnugget = 0\n\n\nSee also CreateComponent, TriangularMap, CreateTriangular\n\n\n\n\n\n","category":"function"},{"location":"map/#MParT.TriangularMap","page":"Map Functionality","title":"MParT.TriangularMap","text":"TriangularMap(maps::Vector, move_coeffs::Bool = true)\n\nCreates a TriangularMap from a vector of ConditionalMapBase objects.\n\nTODO: The new object takes ownership of the coeffs of the maps in maps if move_coeffs is true.\n\nExamples\n\njulia> dim, order = 5, 3;\n\njulia> msets = [FixedMultiIndexSet(d, order) for d in 1:dim];\n\njulia> opts = MapOptions();\n\njulia> components = [CreateComponent(mset, opts) for mset in msets];\n\njulia> trimap = TriangularMap(components);\n\n\n\n\n\n","category":"type"},{"location":"map/#MParT.CreateTriangular","page":"Map Functionality","title":"MParT.CreateTriangular","text":"CreateTriangular(inDim::Int, outDim::Int, p::Int, opts::MapOptions)\n\nCreates a total order p map with dimensions inDim and outDim with specifications opts.\n\n\n\n\n\n","category":"function"},{"location":"map/#MParT.CreateComponent","page":"Map Functionality","title":"MParT.CreateComponent","text":"CreateComponent(mset::FixedMultiIndexSet, opts::MapOptions)\n\nCreate a single-output component with approximation order given by mset and specified by opts\n\n\n\n\n\n","category":"function"},{"location":"extras/","page":"Extras","title":"Extras","text":"CurrentModule = MParT","category":"page"},{"location":"extras/#Routines-not-available-via-Pkg","page":"Extras","title":"Routines not available via Pkg","text":"","category":"section"},{"location":"extras/","page":"Extras","title":"Extras","text":"Serialize\nDeserialize\nDeserializeMap","category":"page"},{"location":"extras/#MParT.Serialize","page":"Extras","title":"MParT.Serialize","text":"Serialize(obj, filename)\n\nSerializes obj into file filename. REQUIRES CEREAL INSTALLATION.\n\n\n\n\n\n","category":"function"},{"location":"extras/#MParT.Deserialize","page":"Extras","title":"MParT.Deserialize","text":"Deserialize(obj, filename)\n\nDeserializes filename and puts the contents in obj. REQUIRES CEREAL INSTALLATION.\n\nThe object obj can be of type MapOptions or FixedMultiIndexSet. This will create a new pointerâ€“ other objects with the same pointer will not be modified, but the contents of obj will now point to the deserialized object.\n\n\n\n\n\n","category":"function"},{"location":"extras/#MParT.DeserializeMap","page":"Extras","title":"MParT.DeserializeMap","text":"DeserializeMap(filename::String)\n\nREQUIRES CEREAL INSTALLATION. Deserializes a map and returns its input dimension, output dimension, and coefficient.\n\n\n\n\n\n","category":"function"},{"location":"trainmap/","page":"Traditional training","title":"Traditional training","text":"CurrentModule = MParT","category":"page"},{"location":"trainmap/#Map-Training-Routines","page":"Traditional training","title":"Map Training Routines","text":"","category":"section"},{"location":"trainmap/","page":"Traditional training","title":"Traditional training","text":"CreateGaussianKLObjective\nTrainOptions\nTrainMap\nTestError","category":"page"},{"location":"trainmap/#MParT.CreateGaussianKLObjective","page":"Traditional training","title":"MParT.CreateGaussianKLObjective","text":"CreateGaussianKLObjective(train)\nCreateGaussianKLObjective(train, outputDim)\nCreateGaussianKLObjective(train, test)\nCreateGaussianKLObjective(train, test, outputDim)\n\nCreate an objective for the optimization problem of training a transport map.\n\nCurrently only supports variational simulation-based inference, i.e. creating a map that uses samples train from target distribution and a Gaussian reference distribution of dimension outputDim. If outputDim is zero, this is equivalent to when outputDim == size(train,1).\n\nArguments\n\ntrain::Matrix{Float64}: mandatory training dataset\ntest::Matrix{Float64}: optional test dataset\noutputDim::Int = 0: Dimensions of output of map\n\nExamples\n\njulia> using Random; rng = Random.Xoshiro(1);\n\njulia> # Replace RNG type with MersenneTwister for <1.7\n\njulia> N, inDim, outDim = 1000, 4, 2;\n\njulia> samples = 2*randn(rng, inDim, N) .+ 5;\n\njulia> obj1 = CreateGaussianKLObjective(samples);\n\njulia> obj2 = CreateGaussianKLObjective(samples, outDim);\n\njulia> train, test = samples[:,1:500], samples[:,501:end];\n\njulia> obj3 = CreateGaussianKLObjective(train, test);\n\njulia> obj4 = CreateGaussianKLObjective(train, test, outDim);\n\nSee also TrainMap, TrainOptions\n\n\n\n\n\n","category":"function"},{"location":"trainmap/#MParT.TrainOptions","page":"Traditional training","title":"MParT.TrainOptions","text":"`TrainOptions(;kwargs...)`\n\nCreates options for using TrainMap to train a transport map.\n\nSee example for possible arguments.\n\nExamples\n\njulia> TrainOptions(opt_alg=\"LD_SLSQP\", opt_maxeval = 1_000_000)\nopt_alg = LD_SLSQP\nopt_stopval = -inf\nopt_ftol_rel = 0.001\nopt_ftol_abs = 0.001\nopt_xtol_rel = 0.0001\nopt_xtol_abs = 0.0001\nopt_maxeval = 1000000\nopt_maxtime = inf\nverbose = 0\n\n\nSee also TrainMap, CreateGaussianKLObjective\n\n\n\n\n\n","category":"function"},{"location":"trainmap/#MParT.TrainMap","page":"Traditional training","title":"MParT.TrainMap","text":"TrainMap(map, obj::MapObjective, opts::TrainOptions)\n\nTrains map according to the objective obj with training options opts.\n\n\n\n\n\n","category":"function"},{"location":"trainmap/#MParT.TestError","page":"Traditional training","title":"MParT.TestError","text":"TestError(obj::MapObjective, map)\n\nUses the test dataset in obj to evaluate the error of map.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MParT","category":"page"},{"location":"#MParT","page":"Home","title":"MParT","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MParT.jl. This documentation is incomplete and only features some basic functionality. For documentation of all functions as well as source installation instructions, other binding information, and many examples, please look at the C++ documentation. If there's a function there unavailable in Julia, please let the developers know via a GitHub issue.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"multiindex.md\", \"map.md\", \"trainmap.md\", \"adaptivemap.md\", \"extras.md\"]","category":"page"},{"location":"#General-Utilities","page":"Home","title":"General Utilities","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Concurrency","category":"page"},{"location":"#MParT.Concurrency","page":"Home","title":"MParT.Concurrency","text":"Concurrency()\n\nSee how many threads MParT is using.\n\n\n\n\n\n","category":"function"},{"location":"adaptivemap/","page":"Adaptive training","title":"Adaptive training","text":"CurrentModule = MParT","category":"page"},{"location":"adaptivemap/#*Adaptive*-Map-Training-Routines","page":"Adaptive training","title":"Adaptive Map Training Routines","text":"","category":"section"},{"location":"adaptivemap/","page":"Adaptive training","title":"Adaptive training","text":"TrainMapAdaptive\nATMOptions","category":"page"},{"location":"adaptivemap/#MParT.TrainMapAdaptive","page":"Adaptive training","title":"MParT.TrainMapAdaptive","text":"TrainMapAdaptive(msets, objective, options)\n\nImplements the ATM algorithm Baptista, et al.\n\nTakes in initial guess of multiindex sets for each output dimension and adapts those sets to better approximate the probability distribution of interest using monotone transport maps.\n\nExamples\n\n\n\n\n\n","category":"function"},{"location":"adaptivemap/#MParT.ATMOptions","page":"Adaptive training","title":"MParT.ATMOptions","text":"`ATMOptions(;kwargs...)`\n\nOptions for using the Adaptive Transport Map algorithm from Baptista, et al.\n\nInherits all keywords from MapOptions and TrainOptions, plus the arguments below.\n\nArguments\n\nmaxPatience::Int: Number of \"stationary\" algorithm iterations tolerated\nmaxSize::Int: the total number of multiindices in the entire map that the algorithm is allowed to add. Should be larger than the sum of the sizes of all multiindex sets across all dimensions for the map\nmaxDegrees::MultiIndex: The maximum degree of any expansion term for each dimension (should be length of dimensions of the map)\n\nExamples\n\njulia> maxDegrees = MultiIndex(2,3); # limit both dimensions by order 3\n\njulia> ATMOptions(opt_alg=\"LD_SLSQP\", maxDegrees=maxDegrees);\n\nSee also TrainMapAdaptive, TrainOptions, MapOptions\n\n\n\n\n\n","category":"function"}]
}
