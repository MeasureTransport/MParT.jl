var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = MParT","category":"page"},{"location":"#MParT","page":"Home","title":"MParT","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MParT.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [MParT]","category":"page"},{"location":"#MParT.ComposedMap-Tuple{Vector{<:CxxWrap.StdLib.SharedPtr{<:MParT.ConditionalMapBase}}}","page":"Home","title":"MParT.ComposedMap","text":"`ComposedMap(maps::Vector)`\n\nCreates a ComposedMap from a vector of ConditionalMapBase objects.\n\n\n\n\n\n","category":"method"},{"location":"#MParT.MultiIndex-Tuple{AbstractVector{<:Int64}}","page":"Home","title":"MParT.MultiIndex","text":"MultiIndex(A::AbstractVector{<:Int})\n\nMultiIndex defines the order of one term of a function expansion for each dimensions.\n\nExample\n\njulia> degrees = [3,2,1]; # Represents polynomial basis function similar to x^3y^2z^1\n\njulia> midx = MultiIndex(degrees);\n\njulia> midx[3]\n0x00000001\n\nSee also MultiIndexSet, FixedMultiIndexSet, Fix\n\n\n\n\n\n","category":"method"},{"location":"#MParT.MultiIndexSet-Tuple{AbstractMatrix{<:Integer}}","page":"Home","title":"MParT.MultiIndexSet","text":"MultiIndexSet(A::AbstractVecOrMat{<:Integer})\n\nCreate a set of MultiIndices from the rows of A.\n\nThese indices represent a basis for a multivariate expansion or, further, monotone expansion. Each element of the set is a MultiIndex representing one basis function via the degrees in each dimension.\n\nExample\n\njulia> # Functions like: c_1xy^2z^3 + c_2xyz + c_3\n\njulia> A = [1 2 3;1 1 1; 0 0 0];\n\njulia> mset = MultiIndexSet(A);\n\nSee alsoMultiIndex, FixedMultiIndex, Fix\n\n\n\n\n\n","category":"method"},{"location":"#MParT.TriangularMap-Tuple{Vector}","page":"Home","title":"MParT.TriangularMap","text":"TriangularMap(maps::Vector)\n\nCreates a TriangularMap from a vector of ConditionalMapBase objects.\n\nExamples\n\njulia> dim, order = 5, 3;\n\njulia> msets = [FixedMultiIndexSet(d, order) for d in 1:dim];\n\njulia> opts = MapOptions();\n\njulia> components = [CreateComponent(mset, opts) for mset in msets];\n\njulia> trimap = TriangularMap(components);\n\n\n\n\n\n","category":"method"},{"location":"#MParT.ATMOptions-Tuple{}","page":"Home","title":"MParT.ATMOptions","text":"`ATMOptions(;kwargs...)`\n\nOptions for using the Adaptive Transport Map algorithm from Baptista, et al.\n\nInherits all keywords from MapOptions and TrainOptions, plus the arguments below.\n\nArguments\n\nmaxPatience::Int: Number of \"stationary\" algorithm iterations tolerated\nmaxSize::Int: the total number of multiindices in the entire map that the algorithm is allowed to add. Should be larger than the sum of the sizes of all multiindex sets across all dimensions for the map\nmaxDegrees::MultiIndex: The maximum degree of any expansion term for each dimension (should be length of dimensions of the map)\n\nExamples\n\njulia> maxDegrees = MultiIndex(2,3); # limit both dimensions by order 3\n\njulia> ATMOptions(opt_alg=\"LD_SLSQP\", maxDegrees=maxDegrees);\n\n\n\n\n\n","category":"method"},{"location":"#MParT.CreateGaussianKLObjective","page":"Home","title":"MParT.CreateGaussianKLObjective","text":"CreateGaussianKLObjective(train)\nCreateGaussianKLObjective(train, outputDim)\nCreateGaussianKLObjective(train, test)\nCreateGaussianKLObjective(train, test, outputDim)\n\nCreate an objective for the optimization problem of training a transport map.\n\nCurrently only supports variational simulation-based inference, i.e. creating a map that uses samples train from target distribution and a Gaussian reference distribution of dimension outputDim. If outputDim is zero, this is equivalent to when outputDim == size(train,1).\n\nArguments\n\ntrain::Matrix{Float64}: mandatory training dataset\ntest::Matrix{Float64}: optional test dataset\noutputDim::Int = 0: Dimensions of output of map\n\nExamples\n\njulia> using Random; rng = Random.Xoshiro(1);\n\njulia> # Replace RNG type with MersenneTwister for <1.7\n\njulia> N, inDim, outDim = 1000, 4, 2;\n\njulia> samples = 2*randn(rng, inDim, N) .+ 5;\n\njulia> obj1 = CreateGaussianKLObjective(samples);\n\njulia> obj2 = CreateGaussianKLObjective(samples, outDim);\n\njulia> train, test = samples[:,1:500], samples[:,501:end];\n\njulia> obj3 = CreateGaussianKLObjective(train, test);\n\njulia> obj4 = CreateGaussianKLObjective(train, test, outDim);\n\nSee alsoTrainMap, TrainMapOptions\n\n\n\n\n\n","category":"function"},{"location":"#MParT.DeserializeMap-Tuple{String}","page":"Home","title":"MParT.DeserializeMap","text":"DeserializeMap(filename::String)\n\nREQUIRES CEREAL INSTALLATION. Deserializes a map and returns its input dimension, output dimension, and coefficient.\n\n\n\n\n\n","category":"method"},{"location":"#MParT.MapOptions-Tuple{}","page":"Home","title":"MParT.MapOptions","text":"MapOptions(;kwargs...)\n\nTakes the fields from MParT's MapOptions as keyword arguments, and assigns the field value based on a String from the kwarg value. Some arguments are included below. See C++ documentation for further detail.\n\nArguments\n\nbasisType::String: Includes \"ProbabilistHermite\", \"PhysicistHermite\", \"HermiteFunctions\"\nbasisLB::Float64,basisUB::Float64: The bounds for where we start linearizing the map. These default to infinities, but often making the data near the origin and setting them to a small finite number (e.g. +-3) works well.\n\nExample\n\njulia> MapOptions(basisType=\"HermiteFunctions\", basisLB=-3., basisUB=3.)\nbasisType = HermiteFunctions\nbasisLB = -3\nbasisUB = 3\nbasisNorm = true\nposFuncType = SoftPlus\nquadType = AdaptiveSimpson\nquadAbsTol = 1e-06\nquadRelTol = 1e-06\nquadMaxSub = 30\nquadMinSub = 0\nquadPts = 5\ncontDeriv = true\n\n\n\n\n\n\n","category":"method"},{"location":"#MParT.TrainMapAdaptive-Tuple{Vector{<:MultiIndexSet}, CxxWrap.StdLib.SharedPtr{<:MParT.MapObjective}, MParT.__ATMOptions}","page":"Home","title":"MParT.TrainMapAdaptive","text":"TrainMapAdaptive(msets, objective, options)\n\nImplements the ATM algorithm Baptista, et al.\n\nTakes in initial guess of multiindex sets for each output dimension and adapts those sets to better approximate the probability distribution of interest using monotone transport maps.\n\nExamples\n\n\n\n\n\n","category":"method"},{"location":"#MParT.TrainOptions-Tuple{}","page":"Home","title":"MParT.TrainOptions","text":"`TrainOptions(;kwargs...)`\n\nTakes the fields from MParT's TrainOptions as keyword arguments, and assigns the field value based on a String from keyword arguments. See example for possible arguments.\n\nExamples\n\njulia> TrainOptions(opt_alg=\"LD_SLSQP\", opt_maxeval = 1_000_000)\nopt_alg = LD_SLSQP\nopt_stopval = -inf\nopt_ftol_rel = 0.001\nopt_ftol_abs = 0.001\nopt_xtol_rel = 0.0001\nopt_xtol_abs = 0.0001\nopt_maxeval = 1000000\nopt_maxtime = inf\nverbose = 0\n\n\nSee alsoTrainMap, CreateGaussianKLObjective\n\n\n\n\n\n","category":"method"}]
}
